#/bin/bash

# TODO: chercher-remplacer basés sur des tableaux utilisables pour les URL, les chemins, les noms d'hôtes...
# TODO: synchronisation de dossiers basée sur des tableaux
declare -A replace_src
declare -A replace_dst
declare -A sync_src
declare -A sync_dst

source $(dirname $0)/etc/config

# activation compression, selon le type de source (gzip supporté globalement, 7z uniquement en remote_file ou local_file) a cause des ses limitations
src_file_extension=""
if [ $compress -gt 0 ];
then
    case "$src_type" in 
        "remote_file" | "local_file")
            src_file_extension=$(echo "${src_file##*.}" | tr '[:upper:]' '[:lower:]');
            if [ "$src_file_extension" == "gz" ];
            then
                DO_GZIP="cat"
                DO_GUNZIP="zcat"
            elif [ "$src_file_extension" == "7z" ];
            then
                DO_GZIP="cat"
                DO_GUNZIP="7zr e -so"
            else
                DO_GZIP="gzip -c "
                DO_GUNZIP="gunzip"
            fi
            ;;
        *)
            DO_GZIP="gzip"
            DO_GUNZIP="gunzip"
            ;;
    esac
    RSYNC_OPTIONS="-vrpz"
else
    DO_GZIP="cat"
    DO_GUNZIP="cat"
    RSYNC_OPTIONS="-vrp"
fi

# gestion des infos de connexion à la base source
arg_src_hostname=""
arg_src_port=""
arg_src_dbuser=""
arg_src_dbpass=""
case "$src_type" in
    "remote_base" | "local_base")
        if [ -n "$src_hostname" ]; then
            arg_src_hostname=" -h $src_hostname "
        fi
        if [ -n "$src_port" ]; then
            arg_src_port=" -P $src_port "
        fi
        if [ -n "$src_dbuser" ]; then
            arg_src_dbuser=" -u $src_dbuser "
        fi
        if [ -n "$src_dbpass" ]; then
            arg_src_dbpass=" -p$src_dbpass "
        fi
        ;;
esac
arg_connexion_src="$arg_src_hostname$arg_src_port$arg_src_dbuser$arg_src_dbpass"

# gestion des infos de connexion à la base destination
arg_dst_hostname=""
arg_dst_port=""
arg_dst_dbuser=""
arg_dst_dbpass=""
if [ -n "$dst_hostname" ]; then
    arg_dst_hostname=" -h $dst_hostname "
fi
if [ -n "$dst_port" ]; then
    arg_dst_port=" -P $dst_port "
fi
if [ -n "$dst_dbuser" ]; then
    arg_dst_dbuser=" -u $dst_dbuser "
fi
if [ -n "$dst_dbpass" ]; then
    arg_dst_dbpass=" -p$dst_dbpass "
fi
arg_connexion_dst="$arg_dst_hostname$arg_dst_port$arg_dst_dbuser$arg_dst_dbpass"

# echappement des variables : caracteres '.' et '/'
curdate=`date +%Y%m%d%H%M%S`
sqlfile="$(dirname $0)/tmp/$src_dbname$curdate.sql"
sqlfile_tmp="$(dirname $0)/tmp/$src_dbname.sql-tmp.$src_file_extension"
sqlfile_backup="$(dirname $0)/tmp/$src_dbname.sql"

# contrôles d'erreurs
if [ "$src_file_extension" == "gz" ];
then
    if [[ ! -x $(which gzip) || ! -x $(which gunzip)  ]];
    then
        echo "Vous avez besoin de gzip et gunzip en local (c'est standard normalement) : # apt-get install gzip"
        exit
    fi
elif [ "$src_file_extension" == "7z" ]
then
    if [[ ! -x $(which 7zr) ]];
    then
        echo "Vous avez besoin de 7zr en local : # apt-get install p7zip"
        exit
    fi
fi

if [ "${#replace_src[@]}" != "${#replace_dst[@]}" ];
then
    echo "Incohérence dans les remplacements demandés, vérifiez les tableaux 'replace_src' et 'replace_dst' dans le fichier $(dirname $0)/etc/config"
    exit
fi

if [ "${#sync_src[@]}" != "${#sync_dst[@]}" ];
then
    echo "Incohérence dans les synchronisations demandées, vérifiez les tableaux 'sync_src' et 'sync_dst' dans le fichier $(dirname $0)/etc/config"
    exit
fi

# backup distant ou local
RECUP_KO=1
case "$src_type" in 
    "remote_file")
        MSG="1/6 : récupération du fichier dump (distant)";
        printf "\r`tput el`%s" "$MSG"
        ssh $src_unixuser@$src_server "$DO_GZIP $src_file" > $sqlfile_tmp && \
            echo "DROP DATABASE IF EXISTS $dst_dbname; CREATE DATABASE $dst_dbname; USE $dst_dbname; " > $sqlfile && \
            $DO_GUNZIP $sqlfile_tmp 2>/dev/null \
            >> $sqlfile && rm -f $sqlfile_tmp
        RECUP_KO=$?
        ;;
    "local_file")
        MSG="1/6 : récupération du fichier dump (local : $src_file)";
        printf "\r`tput el`%s" "$MSG"
        echo "DROP DATABASE IF EXISTS $dst_dbname; CREATE DATABASE $dst_dbname; USE $dst_dbname; " > $sqlfile_tmp && \
            $DO_GUNZIP $src_file 2>/dev/null \
            >> $sqlfile_tmp && mv -f $sqlfile_tmp $sqlfile
        RECUP_KO=$?
        ;;
    "remote_base")
        MSG="1/6 : dump de la base (distante)";
        printf "\r`tput el`%s" "$MSG"
        echo "DROP DATABASE IF EXISTS $dst_dbname; CREATE DATABASE $dst_dbname; USE $dst_dbname; " > $sqlfile_tmp && \
            ssh $src_unixuser@$src_server "($src_path_to_mysqldump --opt -R --no-data $sql_options $arg_connexion_src $src_dbname && $src_path_to_mysqldump --opt -R $sql_options $sql_ignores $arg_connexion_src $src_dbname) | $DO_GZIP" | $DO_GUNZIP \
            >> $sqlfile_tmp && mv -f $sqlfile_tmp $sqlfile
        RECUP_KO=$?
        ;;
    "local_base")
        MSG="1/6 : dump de la base (locale)";
        printf "\r`tput el`%s" "$MSG"
        echo "DROP DATABASE IF EXISTS $dst_dbname; CREATE DATABASE $dst_dbname; USE $dst_dbname; " > $sqlfile_tmp && \
            ($dst_path_to_mysqldump --opt -R --no-data $sql_options $arg_connexion_src $src_dbname && $dst_path_to_mysqldump --opt -R $sql_options $sql_ignores $arg_connexion_src $src_dbname) \
            >> $sqlfile_tmp && mv -f $sqlfile_tmp $sqlfile
        RECUP_KO=$?
        ;;
esac

if [ $RECUP_KO -gt 0 ];
then
    let COL=70-${#MSG}
    printf "%${COL}s\n" "KO"
    exit
else
    let COL=70-${#MSG}
    printf "%${COL}s\n" "OK"
fi

# remplacement des URL et chemins (même sérialisés)
MSG1="2/6 : remplacement de";
MSG2="${#replace_src[@]}";
MSG3="URL et chemins                          "
liste=$(echo "${!replace_src[@]}" | sed 's/ /\n/g' | sort -n)
for k in $liste
do
    replace_src_current_value=${replace_src[$k]}
    replace_dst_current_value=${replace_dst[$k]}
    replace_src_escaped=`echo "${replace_src_current_value}" | sed 's/\//\\\\\//g'`
    MSG4="`expr 1 + $k`"
    MSG5=": ${replace_src_current_value} => ${replace_dst_current_value}"
    printf "\r`tput el`$MSG1 %3d $MSG3 %3d $MSG5" "$MSG2" "$MSG4"
    $dst_path_to_php $dst_path_to_resilient_replace -i "$replace_src_escaped" "$replace_dst_current_value" $sqlfile
done
printf "\r`tput el`$MSG1 %3d $MSG3  OK" "$MSG2"
echo

# adaptation spécifiques
MSG="3/6 : adaptations avant import (fichiers hook/before/*.sh)";
# applique les fichiers dans hook
echo -n "$MSG"

# teste s'il y a des fichiers .sh
shopt -q nullglob || resetnullglob=1; shopt -s nullglob;
files=(hook/before/*.sh); 
[ "$resetnullglob" ] && shopt -u nullglob
# s'il y a des fichiers .sh
if [ ${#files[@]} -gt 0 ];
then
    echo
    for fich in hook/before/*.sh; 
    do
        source $fich;
    done
else
    let COL=70-${#MSG}
    printf "%${COL}s\n" ".."
fi

# importe la BD modifiee
MSG="4/6 : import de la base de donnees"
echo -n "$MSG"
cat $sqlfile | \
    $dst_path_to_mysql $arg_connexion_dst $dst_dbname --show-warnings > $logfile && \
    mv -f $sqlfile $sqlfile_backup && \
    let COL=70-${#MSG} && \
    printf "%${COL}s\n" "OK"

MSG="5/6 : adaptations apres import (fichiers hook/after/*.sh)";
# applique les fichiers dans hook
echo -n "$MSG"
# teste s'il y a des fichiers .sh
shopt -q nullglob || resetnullglob=1; shopt -s nullglob;
files=(hook/after/*.sh); 
[ "$resetnullglob" ] && shopt -u nullglob
# s'il y a des fichiers .sh
if [ ${#files[@]} -gt 0 ];
then
    echo
    for fich in hook/after/*.sh; 
    do
        source $fich;
    done
else
    let COL=70-${#MSG}
    printf "%${COL}s\n" ".."
fi

MSG1="6/6 : synchronisation de";
MSG2="${#sync_src[@]}";
MSG3="dossiers                             "
liste=$(echo "${!sync_src[@]}" | sed 's/ /\n/g' | sort -n)
for k in $liste
do
    sync_src_current_value=${sync_src[$k]}
    sync_dst_current_value=${sync_dst[$k]}
    sync_src_escaped=`echo "${sync_src_current_value}" | sed 's/\//\\\\\//g'`
    MSG4="`expr 1 + $k`"
    MSG5=": ${sync_src_current_value} => ${sync_dst_current_value}"
    printf "\r`tput el`$MSG1 %3d $MSG3 %3d $MSG5" "$MSG2" "$MSG4"
    $dst_path_to_rsync $RSYNC_OPTIONS $src_unixuser@$src_server:$sync_src_current_value $sync_dst_current_value >> $logfile
done
printf "\r`tput el`$MSG1 %3d $MSG3  OK" "$MSG2"
echo
echo

# vim: filetype=sh
