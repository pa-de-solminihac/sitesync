#/bin/bash

# TODO: chercher-remplacer basés sur des tableaux utilisables pour les URL, les chemins, les noms d'hôtes...
# TODO: synchronisation de dossiers basée sur des tableaux
declare -A replace_src
declare -A replace_dst
declare -A sync_src
declare -A sync_dst

source $(dirname $0)/etc/config

if [ "${#replace_src[@]}" != "${#replace_dst[@]}" ];
then
    echo "Incohérence dans les remplacements demandés, vérifiez les tableaux 'replace_src' et 'replace_dst' dans le fichier $(dirname $0)/etc/config"
fi

if [ "${#sync_src[@]}" != "${#sync_dst[@]}" ];
then
    echo "Incohérence dans les synchronisations demandées, vérifiez les tableaux 'sync_src' et 'sync_dst' dans le fichier $(dirname $0)/etc/config"
fi

# activation compression, selon le type de source (gzip supporté globalement, 7z uniquement en remote_file ou local_file) a cause des ses limitations
if [ $compress -gt 0 ];
then
    case "$src_type" in 
        "remote_file" | "local_file")
            src_file_extension=$(echo "${src_file##*.}" | tr '[:upper:]' '[:lower:]');
            if [ "$src_file_extension" == "gz" ];
            then
                DO_GZIP="cat"
                DO_GUNZIP="zcat"
            elif [ "$src_file_extension" == "7z" ];
            then
                DO_GZIP="cat"
                DO_GUNZIP="7zr e -so"
            else
                DO_GZIP="gzip -c "
                DO_GUNZIP="gunzip"
            fi
            ;;
        *)
            DO_GZIP="gzip"
            DO_GUNZIP="gunzip"
            ;;
    esac
    RSYNC_OPTIONS="-vrpz"
else
    DO_GZIP="cat"
    DO_GUNZIP="cat"
    RSYNC_OPTIONS="-vrp"
fi

# echappement des variables : caracteres '.' et '/'
curdate=`date +%Y%m%d%H%M%S`
sqlfile="$(dirname $0)/tmp/$src_dbname$curdate.sql"
sqlfile_tmp="$(dirname $0)/tmp/$src_dbname.sql-tmp.$src_file_extension"
sqlfile_backup="$(dirname $0)/tmp/$src_dbname.sql"

# backup distant ou local
echo "DROP DATABASE IF EXISTS $dst_dbname; CREATE DATABASE $dst_dbname; USE $dst_dbname; " > $sqlfile_tmp
RECUP_KO=1
case "$src_type" in 
    "remote_file")
        MSG="1/6 : récupération du fichier dump (distant)";
        echo -n "$MSG"
        ssh $src_unixuser@$src_server "$DO_GZIP $src_file" >> $sqlfile_tmp && $DO_GUNZIP $sqlfile_tmp 2>/dev/null \
            >> $sqlfile && rm -f $sqlfile_tmp
        RECUP_KO=$?
        ;;
    "local_file")
        MSG="1/6 : récupération du fichier dump (local : $src_file)";
        echo -n "$MSG"
        $DO_GUNZIP $src_file 2>/dev/null \
            >> $sqlfile_tmp && mv -f $sqlfile_tmp $sqlfile
        RECUP_KO=$?
        ;;
    "remote_base")
        MSG="1/6 : dump de la base (distante)";
        echo -n "$MSG"
        ssh $src_unixuser@$src_server "($src_path_to_mysqldump --opt -R --no-data $sql_options -u $src_dbuser $src_dbname && $src_path_to_mysqldump --opt -R $sql_options $sql_ignores -u $src_dbuser $src_dbname) | $DO_GZIP" | $DO_GUNZIP \
            >> $sqlfile_tmp && mv -f $sqlfile_tmp $sqlfile
        RECUP_KO=$?
        ;;
    "local_base")
        MSG="1/6 : dump de la base (locale)";
        echo -n "$MSG"
        ($dst_path_to_mysqldump --opt -R --no-data $sql_options -u $src_dbuser $src_dbname && $dst_path_to_mysqldump --opt -R $sql_options $sql_ignores -u $src_dbuser $src_dbname) \
            >> $sqlfile_tmp && mv -f $sqlfile_tmp $sqlfile
        RECUP_KO=$?
        ;;
esac

if [ $RECUP_KO -gt 0 ];
then
    let COL=70-${#MSG}
    printf "%${COL}s\n" "KO"
    exit
else
    let COL=70-${#MSG}
    printf "%${COL}s\n" "OK"
fi

# remplacement des URL et chemins (même sérialisés)
MSG="2/6 : remplacement de ${#replace_src[@]} URL et chemins";
liste=$(echo "${!replace_src[@]}" | sed 's/ /\n/g' | sort -n)
for k in $liste
do
    replace_src_current_value=${replace_src[$k]}
    replace_dst_current_value=${replace_dst[$k]}
    replace_src_escaped=`echo "${replace_src_current_value}" | sed 's/\//\\\\\//g'`
    echo -ne "$MSG                               `expr 1 + $k` : ${replace_src_current_value} => ${replace_dst_current_value}\033[0K\r"
    $dst_path_to_php $dst_path_to_resilient_replace -i "$replace_src_escaped" "$replace_dst_current_value" $sqlfile
done
echo -ne "$MSG                              OK\033[0K\r"
echo

# adaptation spécifiques
MSG="3/6 : adaptations avant import (fichiers hook/before/*.sh)";
# applique les fichiers dans hook
echo -n "$MSG"

# teste s'il y a des fichiers .sh
shopt -q nullglob || resetnullglob=1; shopt -s nullglob;
files=(hook/before/*.sh); 
[ "$resetnullglob" ] && shopt -u nullglob
# s'il y a des fichiers .sh
if [ ${#files[@]} -gt 0 ];
then
    echo
    for fich in hook/before/*.sh; 
    do
        source $fich;
    done
else
    let COL=70-${#MSG}
    printf "%${COL}s\n" ".."
fi

# importe la BD modifiee
MSG="4/6 : import de la base de donnees"
echo -n "$MSG"
cat $sqlfile | \
    $dst_path_to_mysql -u $dst_dbuser $dst_dbname --show-warnings > $logfile && \
    mv -f $sqlfile $sqlfile_backup && \
    let COL=70-${#MSG} && \
    printf "%${COL}s\n" "OK"

MSG="5/6 : adaptations apres import (fichiers hook/after/*.sh)";
# applique les fichiers dans hook
echo -n "$MSG"
# teste s'il y a des fichiers .sh
shopt -q nullglob || resetnullglob=1; shopt -s nullglob;
files=(hook/after/*.sh); 
[ "$resetnullglob" ] && shopt -u nullglob
# s'il y a des fichiers .sh
if [ ${#files[@]} -gt 0 ];
then
    echo
    for fich in hook/after/*.sh; 
    do
        source $fich;
    done
else
    let COL=70-${#MSG}
    printf "%${COL}s\n" ".."
fi

MSG="6/6 : synchronisation de ${#sync_src[@]} dossiers";
let COL=70-${#MSG}
liste=$(echo "${!sync_src[@]}" | sed 's/ /\n/g' | sort -n)
for k in $liste
do
    sync_src_current_value=${sync_src[$k]}
    sync_dst_current_value=${sync_dst[$k]}
    sync_src_escaped=`echo "${sync_src_current_value}" | sed 's/\//\\\\\//g'`
    echo -ne "$MSG                                  `expr 1 + $k` : ${sync_src_current_value} => ${sync_dst_current_value}\033[0K\r"
    $dst_path_to_rsync $RSYNC_OPTIONS $src_unixuser@$src_server:$sync_src_current_value $sync_dst_current_value >> $logfile
done
echo -ne "$MSG                                 OK\033[0K\r"
echo
echo

# vim: filetype=sh
