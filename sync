#/bin/bash
source $(dirname $0)/etc/config
# activation compression, selon le type de source (gzip supporté globalement, 7z uniquement en remote_file ou local_file) a cause des ses limitations
if [ $compress -gt 0 ];
then
    case "$src_type" in 
        "remote_file" | "local_file")
            src_file_extension=$(echo "${src_file##*.}" | tr '[:upper:]' '[:lower:]');
            if [ "$src_file_extension" == "gz" ];
            then
                DO_GZIP="cat"
                DO_GUNZIP="zcat"
            elif [ "$src_file_extension" == "7z" ];
            then
                DO_GZIP="cat"
                DO_GUNZIP="7zr e -so"
            else
                DO_GZIP="gzip -c "
                DO_GUNZIP="gunzip"
            fi
            ;;
        *)
            DO_GZIP="gzip"
            DO_GUNZIP="gunzip"
            ;;
    esac
else
    DO_GZIP="cat"
    DO_GUNZIP="cat"
fi

# echappement des variables : caracteres '.' et '/'
curdate=`date +%Y%m%d%H%M%S`
src_root_url_escaped=`echo "$src_root_url"   | sed 's/\//\\\\\//g'`
src_hostname_escaped=`echo "$src_hostname"   | sed 's/\//\\\\\//g'`
dst_root_url_escaped=`echo "$dst_root_url"   | sed 's/\//\\\\\//g'`
dst_hostname_escaped=`echo "$dst_hostname"   | sed 's/\//\\\\\//g'`
src_root_fs_escaped=`echo "$src_root_fs"     | sed 's/\//\\\\\//g'`
dst_root_fs_escaped=`echo "$dst_root_fs"     | sed 's/\//\\\\\//g'`
sqlfile="$(dirname $0)/tmp/$src_dbname$curdate.sql"
sqlfile_tmp="$(dirname $0)/tmp/$src_dbname.sql-tmp.$src_file_extension"
sqlfile_backup="$(dirname $0)/tmp/$src_dbname.sql"

# backup distant ou local
echo "DROP DATABASE IF EXISTS $dst_dbname; CREATE DATABASE $dst_dbname; USE $dst_dbname; " > $sqlfile_tmp
RECUP_KO=1
case "$src_type" in 
    "remote_file")
        MSG="1/5 : récupération du fichier dump (distant)";
        echo -n "$MSG"
        ssh $src_unixuser@$src_server "$DO_GZIP $src_file" >> $sqlfile_tmp && $DO_GUNZIP $sqlfile_tmp 2>/dev/null \
            >> $sqlfile && rm -f $sqlfile_tmp
        RECUP_KO=$?
        ;;
    "local_file")
        MSG="1/5 : récupération du fichier dump (local : $src_file)";
        echo -n "$MSG"
        $DO_GUNZIP $src_file 2>/dev/null \
            >> $sqlfile_tmp && mv -f $sqlfile_tmp $sqlfile
        RECUP_KO=$?
        ;;
    "remote_base")
        MSG="1/5 : dump de la base (distante)";
        echo -n "$MSG"
        ssh $src_unixuser@$src_server "($src_path_to_mysqldump --opt -R --no-data $sql_options -u $src_dbuser $src_dbname && $src_path_to_mysqldump --opt -R $sql_options $sql_ignores -u $src_dbuser $src_dbname) | $DO_GZIP" | $DO_GUNZIP \
            >> $sqlfile_tmp && mv -f $sqlfile_tmp $sqlfile
        RECUP_KO=$?
        ;;
    "local_base")
        MSG="1/5 : dump de la base (locale)";
        echo -n "$MSG"
        ($dst_path_to_mysqldump --opt -R --no-data $sql_options -u $src_dbuser $src_dbname && $dst_path_to_mysqldump --opt -R $sql_options $sql_ignores -u $src_dbuser $src_dbname) \
            >> $sqlfile_tmp && mv -f $sqlfile_tmp $sqlfile
        RECUP_KO=$?
        ;;
esac

if [ $RECUP_KO -gt 0 ];
then
    let COL=70-${#MSG}
    printf "%${COL}s\n" "KO"
    exit
else
    let COL=70-${#MSG}
    printf "%${COL}s\n" "OK"
fi

# remplacement des URL et chemins (même sérialisés)
MSG="2/5 : remplacement des URL et chemins (meme serialises)";
echo -n "$MSG"
$dst_path_to_php $dst_path_to_resilient_replace -i "$src_root_url_escaped" "$dst_root_url" $sqlfile
$dst_path_to_php $dst_path_to_resilient_replace -i "$src_root_fs_escaped" "$dst_root_fs" $sqlfile
let COL=70-${#MSG}
printf "%${COL}s\n" "OK"

# adaptation spécifiques
MSG="3/5 : adaptations avant import (fichiers hook/before/*.sh)";
# applique les fichiers dans hook
echo -n "$MSG"

# teste s'il y a des fichiers .sh
shopt -q nullglob || resetnullglob=1; shopt -s nullglob;
files=(hook/before/*.sh); 
[ "$resetnullglob" ] && shopt -u nullglob
# s'il y a des fichiers .sh
if [ ${#files[@]} -gt 0 ];
then
    echo
    for fich in hook/before/*.sh; 
    do
        source $fich;
    done
else
    let COL=70-${#MSG}
    printf "%${COL}s\n" ".."
fi

# importe la BD modifiee
MSG="4/5 : import de la base de donnees"
echo -n "$MSG"
cat $sqlfile | \
    $dst_path_to_mysql -u $dst_dbuser $dst_dbname --show-warnings > $logfile && \
    mv -f $sqlfile $sqlfile_backup && \
    let COL=70-${#MSG} && \
    printf "%${COL}s\n" "OK"

MSG="5/5 : adaptations apres import (fichiers hook/after/*.sh)";
# applique les fichiers dans hook
echo -n "$MSG"
# teste s'il y a des fichiers .sh
shopt -q nullglob || resetnullglob=1; shopt -s nullglob;
files=(hook/after/*.sh); 
[ "$resetnullglob" ] && shopt -u nullglob
# s'il y a des fichiers .sh
if [ ${#files[@]} -gt 0 ];
then
    echo
    for fich in hook/after/*.sh; 
    do
        source $fich;
    done
else
    let COL=70-${#MSG}
    printf "%${COL}s\n" ".."
fi

# vim: filetype=sh
